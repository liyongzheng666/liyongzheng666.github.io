[{"categories":["Shell"],"content":"更方便的部署环境！","date":"2022-06-28","objectID":"/shell/","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Shell"],"content":"Shell应知应会 第一个Shell程序 解释器的交互环境 优点： 及时看到代码结果 缺点： 代码不能永久保存 把代码写入文件中，脚本程序 优点： 程序永久保存，重复使用 bash运行步骤： 首先启动bash解释器 然后将程序由存储器读取到内存中 解释器件读取的程序，并且运行其中的内容，有问题就报错 运行shell脚本的四种方式 绝对路径 权限问题： 对沿途的文件夹都应该有执行既x权限 chmod o+X 文件名 对保存脚本的这个文件夹需要有读和执行既r+x权限 用法： 直接附上自己的绝对路径即可 相对路径 权限问题： 同上 同上 用法； 必须加上./作为前缀 加上解释器作为前缀：bash 文件路径（绝对、相对都可） 对沿途的文件夹都应该有执行权限 对目标的bash文件具有读权限即可 用法：直接在路径前面加入bash 用source命令执行或者在路径前加.空格 1. 介绍这四种启动方式的不同 虽然四者都是开辟了子进程，但是前者与父进程没有内存关系，后者有 最明显的就是，后者可以查看父进程的变量值 ","date":"2022-06-28","objectID":"/shell/:0:0","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Shell"],"content":"脚本调试功能 每一行代码执行前都会显示该执行语句 bash -x 1.sh 可以显示注释 bash -vx 1.sh 只调试部分代码，需要在脚本中进行添加内容 #下面的代码是脚本中的内容 #-x和+x之前的会逐步运行 set -x echo 111 echo 222 set +x echo 333 ","date":"2022-06-28","objectID":"/shell/:0:1","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Shell"],"content":"Shell语法中变量与变量值的处理 ","date":"2022-06-28","objectID":"/shell/:1:0","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Shell"],"content":"变量 介绍 变量名 赋值符号 变量值：数据 原则:先定义后引用 #定义 qian=30000 #引用 $qian#此时会显示30000，但是后面会有一些错误 #删除 unset qian#qian这个变量就会被释放 #echo指令：打印的功效 echo $qian #这样仅仅会打印 #打印数值后面还要有字符 echo ${qian}MY #这样后面就会有我们想要的东西了 变量名的命名规范：知道啥意思！不能与关键字重复！ 小写字母加下划线-\u003eage_of_women=18 驼峰风格——-\u003eAgeOfWomen=18 变量值来源 直接赋值 可以通过脚本运行命令后面跟变量 $1 $2是在脚本运行后面的变量赋值到脚本程序中使用 与用户交互来获取相关的值 #下一行将要求您输入一个字符串，要求输入内容，赋给name read -p \"请输入您的账号：\" name #可以给输入加一个限定的时间,超时时间便会跳过！ read -p \"请输入您的账号：\" -t 5 name #可以限制字符数量 read -p \"请输入您的账号：\" -n 2 name 格式化输出： shell脚本语言 user=\"liyongzheng\" mima_login=\"li618328\" #注意下面一定使用的是双引号，否则打印出来的就是所谓的符号！ echo \"my name is $user my age is $mima_login\" c语言 user=\"liyongzheng\" mima_login=\"li618328\" //注意下面一定使用的是双引号，否则打印出来的就是所谓的符号！ printf \"my name is %s,my mima is %s\\n\" $user $mima_login 预定义变量 $* :获取所有的位置参数 $@ ：获取所有的位置参数 $# : 获取所有的位置参数个数 $$ :获取当前shell进程的pid $? :获取上一条命令是否运行成功 常量:不能被改变的值 readonly y =1000 ","date":"2022-06-28","objectID":"/shell/:1:1","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Shell"],"content":"变量值的处理 基本数据类型 整形 浮点型 字符串 引用的字符具有特殊意义 echo “=========\u003e$x” 引用的字符没有特殊意义 echo ‘=========\u003e$x’ 下面的这种方式虽然是双引号，但是我们可以在符号前面加一个转译符号即可无意义 echo “=========\u003e$x” 数组：存取多个数值，并且可以顺利存取 普通数组: declare -a hobby=(\"抽烟\" \"烫头\" \"打麻将\")#=附近不能有空格 #下面这个语句则是查看目前已有的数组 declare -a | grep hobby declare -a hobby hobby[0]=1111 hobby[1]=2222 hobby[2]=3333 echo ${hobby[0]} 关联数组: declare -A :star::储存一个人的信息，年龄的时候，因为数据类型不一致， :star::但是这些数据都与一个人高度关联，所以出现关联数组！ declare -A info=([\"name\"]=\"goudaner\" [\"age\"]=18 [\"gender\"]=\"male\") echo ${info[\"name\"]} :sparkling_heart:：shell是一门弱类型的语言意味着即使是字符串与数字也可以做运算 x=1; u=\"100\" expr $x +$y #最终的结果可以显示101！！！ 变量值的相关操作 获取变量的长度 x=\"hello\" echo ${#x} #打印出来的结果就是x的长度：5 #下面是其他的几种方式也可以 expr length \"$x\" #下面的两种是自动忽视空格，即无论多少个空格都只算做一个空格 echo $x | wc -L echo $x | awk '{print length}' 切片：取字符串的一部分 msg=\"nihaoweilai\" echo ${msg} echo ${msg:1}#打印结果：ihaoweilai echo ${msg:1:3}#打印结果：iha echo ${msg::3}#打印结果：nih 截断：与切片的功能的类似，但是对于处理长字符串更直接一些 curl=\"www.baidu.com.cn\" #截取部分进行赋值 curl1=`echo ${curl#*.}`#curl1的值: baidu.com.cn curl1=`echo ${curl%.*}`#curl1的值: www.baidu.com echo ${curl} #下面介绍的是从左向右进行#截断 echo ${curl#www.}#打印结果：baidu.com.cn echo ${curl#*.}#打印结果：baidu.com.cn echo ${msg##*.}#打印结果：cn #下面介绍的是从右向左进行%截断 echo ${curl%.cn}#打印结果： www.baidu.com echo ${curl%.*} #打印结果： www.baidu.com echo ${curl%%.*}#打印结果： www 替换：进行字符串变量的部分内容替换 部分成员替换 #进行部分词语替换 curl=\"www.baidu.com.cn\" #对curl里面的baidu进行sina替换 echo ${curl/baidu/sina} #对curl里面所有c的字符进行C替换 echo ${curl//c/C} 文件名字替换 #这里介绍一下文件名字的替换 #首先创建一堆空文件名字，然后对统一的名字进行重命名 touch egon_2022_{01..05}_linux.txt for f in `ls .`;#对文件中所有的文件名进行赋值到f do mv $f ${f/_linux/}; done #d都用来执行这一句画画 let和unset替换 #let命令非常有用！！ let x++#自加 let x--#自减 #unset就是释放一个变量 #但是我们插入一个变量输出提示 #假设这里x没有赋值 echo ${x:-没有对应值输出} #若x没有赋值所以这里输出为-后面的内容,但是没有将后面的数值赋给x echo ${x:?没有对应值输出} #这里只是给一个提醒 echo ${x:=没有对应值输出} #若x没有赋值所以这里输出=后面的内容，并且把=后面的内容赋给x #假设这里x已经赋值 echo ${x+没有对应值输出} #若x已经赋值所以这里输出+后面的内容，并且把+后面的内容赋给x 算术运算符 浮点运算：bc #首先安装bc echo \"scale=2;10/3\" | bc #对10/3进行运算 echo \"scale=2;10/3\" | bc | cut -d.-f2#对10/3进行运算后取小数点后的位置且取两位 整数运算 #主要的方式 #expr expr $x +$y #$(()) $((1+2)) $(( $x + $y ))` #$[这里面可以写一些判断] $[ $x + $y ] #let let $a++#这里让a这个变量自加1 #let这种方式只能是++或者--这一种方式 #如果是想a自加10，则需要使用双括号 ((a+=10)) #如果出现乘法需要对*符号进行转译,前面加\\ $[ $x \\* $y ] #写一个自动加减乘除的脚本 a=$1 b=$2 #这里重点介绍一下下面的判断语句 #[]括号里面是一个简短的判断后面则是不满足的情况下应该输出 #[-ne]代表的是不等于的意思 [ $# -ne 2 ] \u0026\u0026 { echo \"请输入两位数字信息\" exit } echo \"a-b=$(($1-$2))\" echo \"a+b=$(($1+$2))\" echo \"a/b=$(($1/$2))\" echo \"a*b=$(($1*$2))\" 测试运算符:test与[]同意思 测试一个文件夹(目录)是否存在-\u003etest -d [ -d ~/test_sh(文件路径) ] ; echo $? #返回1为假，返回0为真 测试一个文件or文件夹内部是否有东西-\u003e test -s [ -s 1.txt ] ; echo $? #返回1为假，返回0为真 测试该文件是否为标准文件-f/该文件是否有写权限-w [ -f 1.txt ] ; echo $? #返回1为假，返回0为真 [ -w 1.txt ] ; echo $? #返回1为假，返回0为真 测试一个文件是否为链接文件-\u003e-L ln -s 1.txt 3.txt# [ -L 3.txt ] ; echo $? #返回1为假，返回0为真 :star::字符串在[]中使用的过程中必须要有引号既“$x” 5. 字符串长度测试是否为零-n 6. 字符串长度是否为非零-z 7. 判断字符串是否相等 [ \"abc\" = \"ab\" ];echo $?#不相等返回1 #拓展：如果判断的东西为数字的时候 =----\u003e-eq \u003e----\u003e-gt \u003c----\u003e-lt \u003e=----\u003e-ge \u003c=----\u003e-le !=----\u003e-ne 简单的测试 read -p \"usrname\u003e\u003e\u003e\u003e\u003e\u003e:\" in_usr usrname\u003e\u003e\u003e\u003e\u003e\u003e:li read -p \"usrlogin\u003e\u003e\u003e\u003e\u003e\u003e:\" in_login usrname\u003e\u003e\u003e\u003e\u003e\u003e:123 [ \"$in_usr\" = \"li\" -a \"$in_login\" = \"123\" ];echo $? #返回值为0 ","date":"2022-06-28","objectID":"/shell/:1:2","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Shell"],"content":"元字符\u0026\u0026流程控制 元字符 [[]]这种形式是支持正则表达式 [ $# -ne 1 ] \u0026\u0026 echo \"只可以传入一个参数\" \u0026\u0026 exit [[ ! $1 =~ ^[0-9]+$ ]] \u0026\u0026 echo \"只能传入数字\" \u0026\u0026 exit #写一个只能传入两个数值信息的脚本，然后输出脚本比较大小的情况 [ $# -ne 2 ] \u0026\u0026 echo \"Usage: $0 arg1 arg2\" \u0026\u0026 exit #下面这两个语句是正则表达式，判断这两个输入参数是否为整形或者浮点型 [[ ! $1 =~ ^[0-9]+(\\.[0-9]+)?$ ]] \u0026\u0026 echo \"第一个参数必须是整数\" \u0026\u0026 exit [[ ! $2 =~ ^[0-9]+(\\.[0-9]+)?$ ]] \u0026\u0026 echo \"第二个参数必须是整数\" \u0026\u0026 exit #下面这部分可以使用bc命令来实现 res=`[ $1 -gt $2] | bc` #介绍一些符号的使用 #！的使用，当文件夹下面有这些文件 #1.txt 2.txt 3.txt 4.txt a.txt b.txt #筛选出那些字母开头的内容 ls [!0-9].txt ls [^0-9].txt #筛选出那些非字母开头的内容 ls [0-9].txt #并发运行程序 流程控制 if判断 while循环 for循环 echo '注意两端的括号都是单引号'. ","date":"2022-06-28","objectID":"/shell/:1:3","tags":["Shell"],"title":"Shell学习总结","uri":"/shell/"},{"categories":["Docker"],"content":"如果你还在为配置环境一系列的问题而烦忧，现在就开始拥抱docker吧！","date":"2022-06-27","objectID":"/docker/","tags":["Docker"],"title":"Docker入门","uri":"/docker/"},{"categories":["Docker"],"content":"Docker初步入门 这里不在介绍docker的理论知识，重点是对用到的一些内容进行总结，方便日后使用 ","date":"2022-06-27","objectID":"/docker/:0:0","tags":["Docker"],"title":"Docker入门","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 这里我们是在云服务器进行的部署，所以基本的工作环境如下 准备工作 #yum包进行更新 # yum remove docker docker-common docker-selinux docker-engine # rm -rf /var/lib/docker sudo yum update #安装软件包以及相关的依赖 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 #给yum配置阿里云 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装Docker软件 sudo yum install docker-ce docker -v 设置USTC的镜像 vi /etc/docker/daemon.json #进入文件之后可以继续输入以下内容 { \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"] } ","date":"2022-06-27","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker入门","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的启动与停止 启动Docker： systemctl start docker 停止Docker： systemctl stop docker 重新启动Docker： systemctl restart docker 查看Docker状态： systemctl status docker 开机启动： systemctl enable docker ","date":"2022-06-27","objectID":"/docker/:2:0","tags":["Docker"],"title":"Docker入门","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像相关的命令 ","date":"2022-06-27","objectID":"/docker/:3:0","tags":["Docker"],"title":"Docker入门","uri":"/docker/"},{"categories":["Test"],"content":"这个地方是用来简短的描述这个博客是用来干啥的.","date":"2022-06-22","objectID":"/first/","tags":["HUGO"],"title":"First Blog","uri":"/first/"},{"categories":["Test"],"content":"生活从来都不是一帆风顺 充满波折的世界永远属于喜欢探索的人 我们首次进行更新 我们必须意 这次为什么可以了 官方的主题教程 https://hugoloveit.com/zh-cn/theme-documentation-basics/ 第一次非常有用的git推送 https://zhuanlan.zhihu.com/p/397612900 大佬的美化教程 https://lewky.cn/posts/hugo-3-3/ 这里插入一些小图标 去露营啦!  很快就回来. 真开心! 横幅种类，起到的是警示作用 Note 一个 注意 横幅 Abstract 一个 摘要 横幅 Info 一个 信息 横幅 Tip 一个 技巧 横幅 Success 一个 成功 横幅 Question 一个 问题 横幅 Warning 一个 警告 横幅 Failure 一个 失败 横幅 Danger 一个 危险 横幅 Bug 一个 Bug 横幅 Example 一个 示例 横幅 Quote 一个 引用 横幅 这里是序列表达 祝贺 庆祝 高兴 然后 兴奋 亢奋 这里是代码区域，但是不知道为什么没有高亮 #include \u003ciostream\u003e #include \u003cvector\u003e 充当模板 ","date":"2022-06-22","objectID":"/first/:0:0","tags":["HUGO"],"title":"First Blog","uri":"/first/"}]